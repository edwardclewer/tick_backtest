# Copyright 2025 Edward Clewer
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Analyse backtest trades stored in Parquet format."""

from __future__ import annotations

import logging
import math
from pathlib import Path
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from tick_backtest.logging_utils import configure_logging, generate_run_id

TRADING_DAYS_PER_YEAR = 252
logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class TradeAnalysisResult:
    """Container for artefacts generated by ``run_trade_analysis``."""

    trades_path: Path
    metrics: Dict[str, object]
    report_path: Optional[Path]
    plot_path: Optional[Path]


def compute_per_trade_sharpe(returns: pd.Series) -> float:
    if returns.empty:
        return float("nan")
    clean = returns.dropna()
    if clean.empty:
        return float("nan")
    mean = clean.mean()
    std = clean.std(ddof=1)
    if std == 0 or np.isnan(std):
        return float("nan")
    return float(mean / std * math.sqrt(clean.count()))


def compute_daily_sharpe(df: pd.DataFrame) -> Tuple[float, pd.Series]:
    if df.empty:
        return float("nan"), pd.Series(dtype=float)
    equity = df.set_index("exit_time")["cumulative_pnl"].sort_index()
    daily_equity = equity.resample("1D").last().ffill()
    daily_returns = daily_equity.diff().dropna()
    if daily_returns.empty:
        return float("nan"), daily_returns
    mean = daily_returns.mean()
    std = daily_returns.std(ddof=1)
    if std == 0 or np.isnan(std):
        return float("nan"), daily_returns
    sharpe = float(mean / std * math.sqrt(TRADING_DAYS_PER_YEAR))
    return sharpe, daily_returns


def load_trades(path: Path) -> pd.DataFrame:
    if not path.exists():
        raise FileNotFoundError(f"Trades file not found: {path}")

    df = pd.read_parquet(path)
    if df.empty:
        raise ValueError(f"Trades file {path} contains no rows")

    required_cols = {"entry_time", "exit_time", "pnl_pips"}
    missing = required_cols.difference(df.columns)
    if missing:
        raise ValueError(f"Trades file missing required columns: {sorted(missing)}")

    df = df.copy()
    df["entry_time"] = pd.to_datetime(df["entry_time"], utc=True, errors="coerce")
    df["exit_time"] = pd.to_datetime(df["exit_time"], utc=True, errors="coerce")
    df.sort_values("exit_time", inplace=True)
    return df


def compute_drawdown(series: pd.Series) -> Tuple[float, pd.Timedelta]:
    if series.empty:
        return 0.0, pd.Timedelta(0)
    running_max = series.cummax()
    drawdown = series - running_max
    min_dd = float(drawdown.min()) if not drawdown.empty else 0.0
    if drawdown.empty or drawdown.idxmin() is pd.NaT:
        return min_dd, pd.Timedelta(0)
    dd_end = drawdown.idxmin()
    peak_series = series.loc[:dd_end]
    if peak_series.empty:
        return min_dd, pd.Timedelta(0)
    dd_start = peak_series.idxmax()
    duration = dd_end - dd_start if (dd_end is not pd.NaT and dd_start is not pd.NaT) else pd.Timedelta(0)
    return min_dd, duration


def compute_performance_metrics(df: pd.DataFrame) -> Dict[str, object]:
    metrics: Dict[str, object] = {}

    metrics["total_trades"] = len(df)
    profits = df[df["pnl_pips"] > 0]
    losses = df[df["pnl_pips"] < 0]
    breakeven = df[df["pnl_pips"] == 0]

    metrics["winning_trades"] = len(profits)
    metrics["losing_trades"] = len(losses)
    metrics["breakeven_trades"] = len(breakeven)
    metrics["win_rate"] = (len(profits) / len(df)) if len(df) else float("nan")

    metrics["net_pnl_pips"] = df["pnl_pips"].sum()
    metrics["gross_profit_pips"] = profits["pnl_pips"].sum()
    metrics["gross_loss_pips"] = losses["pnl_pips"].sum()
    metrics["avg_trade_pips"] = df["pnl_pips"].mean() if len(df) else float("nan")
    metrics["avg_win_pips"] = profits["pnl_pips"].mean() if len(profits) else float("nan")
    metrics["avg_loss_pips"] = losses["pnl_pips"].mean() if len(losses) else float("nan")

    metrics["profit_factor"] = (
        metrics["gross_profit_pips"] / abs(metrics["gross_loss_pips"])
        if metrics["gross_loss_pips"] < 0
        else math.inf if metrics["gross_profit_pips"] > 0 else float("nan")
    )

    metrics["expectancy_pips"] = metrics["avg_trade_pips"]

    metrics["median_trade_pips"] = df["pnl_pips"].median() if len(df) else float("nan")
    metrics["best_trade_pips"] = df["pnl_pips"].max() if len(df) else float("nan")
    metrics["worst_trade_pips"] = df["pnl_pips"].min() if len(df) else float("nan")

    df["holding_seconds"] = (df["exit_time"] - df["entry_time"]).dt.total_seconds()
    metrics["avg_holding_minutes"] = (df["holding_seconds"].mean() / 60.0) if len(df) else float("nan")

    per_trade_sharpe = compute_per_trade_sharpe(df["pnl_pips"])
    metrics["per_trade_sharpe"] = per_trade_sharpe

    df["cumulative_pnl"] = df["pnl_pips"].cumsum()
    max_dd, dd_duration = compute_drawdown(df.set_index("exit_time")["cumulative_pnl"])
    metrics["max_drawdown_pips"] = max_dd
    metrics["max_drawdown_duration"] = dd_duration

    daily_sharpe, daily_returns = compute_daily_sharpe(df)
    metrics["daily_sharpe"] = daily_sharpe
    metrics["daily_return_std"] = daily_returns.std(ddof=1) if not daily_returns.empty else float("nan")
    metrics["daily_return_mean"] = daily_returns.mean() if not daily_returns.empty else float("nan")
    metrics["sampled_days"] = len(daily_returns)

    return metrics


def format_metrics(metrics: Dict[str, object]) -> List[Tuple[str, str]]:
    def fmt(value: object, precision: int = 4) -> str:
        if isinstance(value, (float, np.floating)):
            if np.isnan(value):
                return "NaN"
            if math.isinf(value):
                return "âˆž"
            return f"{value:.{precision}f}"
        if isinstance(value, pd.Timedelta):
            return str(value)
        return f"{value}"

    return [
        ("Total trades", f"{metrics['total_trades']:,}"),
        ("Winning trades", f"{metrics['winning_trades']:,}"),
        ("Losing trades", f"{metrics['losing_trades']:,}"),
        ("Breakeven trades", f"{metrics['breakeven_trades']:,}"),
        ("Win rate", f"{metrics['win_rate']*100:.2f}%" if not math.isnan(metrics['win_rate']) else "NaN"),
        ("Net PnL (pips)", fmt(metrics["net_pnl_pips"], 2)),
        ("Gross profit (pips)", fmt(metrics["gross_profit_pips"], 2)),
        ("Gross loss (pips)", fmt(metrics["gross_loss_pips"], 2)),
        ("Profit factor", fmt(metrics["profit_factor"], 3)),
        ("Expectancy (pips/trade)", fmt(metrics["expectancy_pips"], 3)),
        ("Average trade (pips)", fmt(metrics["avg_trade_pips"], 3)),
        ("Average win (pips)", fmt(metrics["avg_win_pips"], 3)),
        ("Average loss (pips)", fmt(metrics["avg_loss_pips"], 3)),
        ("Median trade (pips)", fmt(metrics["median_trade_pips"], 3)),
        ("Best trade (pips)", fmt(metrics["best_trade_pips"], 3)),
        ("Worst trade (pips)", fmt(metrics["worst_trade_pips"], 3)),
        ("Avg holding time", fmt(metrics["avg_holding_minutes"], 2) + " min" if not math.isnan(metrics["avg_holding_minutes"]) else "NaN"),
        ("Per-trade Sharpe", fmt(metrics["per_trade_sharpe"], 3)),
        ("Daily Sharpe (annualised)", fmt(metrics["daily_sharpe"], 3)),
        ("Daily return mean", fmt(metrics["daily_return_mean"], 3)),
        ("Daily return stdev", fmt(metrics["daily_return_std"], 3)),
        ("Sampled trading days", f"{metrics['sampled_days']:,}"),
        ("Max drawdown (pips)", fmt(metrics["max_drawdown_pips"], 3)),
        ("Max drawdown duration", fmt(metrics["max_drawdown_duration"])),
    ]


def plot_equity_curve(df: pd.DataFrame, plot_path: Path) -> Optional[Path]:
    if plt is None:
        return None

    plt.figure(figsize=(10, 6))
    plt.plot(df["exit_time"], df["cumulative_pnl"], marker="o", linewidth=1.5)
    plt.title("Cumulative PnL (Base Currency Units)")
    plt.xlabel("Exit Time (UTC)")
    plt.ylabel("Cumulative Profit")
    plt.grid(True, linestyle="--", alpha=0.4)
    plt.tight_layout()

    plot_path.parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(plot_path, dpi=200)
    plt.close()
    logger.info("equity curve saved", extra={"plot_path": str(plot_path)})
    return plot_path


def default_plot_path(trades_path: Path) -> Path:
    return trades_path.with_name(trades_path.stem + "_equity_curve.png")


def default_report_path(trades_path: Path) -> Path:
    return trades_path.with_name(trades_path.stem + "_report.md")


def write_report(report_path: Path, trades_path: Path, metrics: Dict[str, object], plot_path: Optional[Path]) -> None:
    report_lines = [
        "# Trade Performance Report",
        "",
        f"**Trades file:** `{trades_path}`",
        f"**Trade count:** {metrics['total_trades']:,}",
        "",
        "## Key Metrics",
        "",
    ]

    for label, value in format_metrics(metrics):
        report_lines.append(f"- **{label}:** {value}")

    report_lines.extend(
        [
            "",
            "## Notes",
            "",
            "- `Per-trade Sharpe` treats each trade PnL as an observation."
            " For institutional reporting, the `Daily Sharpe (annualised)` is preferred",
            " as it aggregates PnL by exit day and annualises using 252 trading days.",
        ]
    )

    if plot_path is not None:
        report_lines.extend([
            "",
            f"![Equity Curve]({plot_path.name})",
        ])

    report_path.parent.mkdir(parents=True, exist_ok=True)
    report_path.write_text("\n".join(report_lines))
    logger.info("report saved", extra={"report_path": str(report_path)})


def analyse_trades(
    df: pd.DataFrame,
    trades_path: Path,
    *,
    plot_path: Optional[Path] = None,
    report_path: Optional[Path] = None,
    generate_plot: bool = True,
    generate_report: bool = True,
) -> Dict[str, object]:
    df = df.copy()
    df["pnl_base"] = df["pnl_pips"]
    df["cumulative_pnl"] = df["pnl_base"].cumsum()

    display_cols = [
        "entry_time",
        "exit_time",
        "direction",
        "entry_price",
        "exit_price",
        "pnl_pips",
        "outcome_label",
    ]
    available_cols = [col for col in display_cols if col in df.columns]
    trades_preview = df[available_cols].to_string(index=False)
    logger.info("executed trades", extra={"table": trades_preview})

    metrics = compute_performance_metrics(df)

    for label, value in format_metrics(metrics):
        logger.info("performance metric", extra={"label": label, "value": value})

    if generate_plot and plot_path is not None:
        plot_equity_curve(df, plot_path)

    if generate_report and report_path is not None:
        write_report(report_path, trades_path, metrics, plot_path if plt else None)

    return metrics


def run_trade_analysis(
    trades_path: Path | str,
    *,
    output_dir: Path | str | None = None,
    plot_filename: Optional[str] = None,
    report_filename: Optional[str] = None,
    generate_plot: bool = True,
    generate_report: bool = True,
    configure_logs: bool = False,
    run_id: Optional[str] = None,
    log_dir: Optional[Path | str] = None,
) -> TradeAnalysisResult:
    """Execute trade analysis for a single trades parquet file."""

    trades_path = Path(trades_path).expanduser()
    df = load_trades(trades_path)

    output_root = Path(output_dir).expanduser() if output_dir else trades_path.parent
    output_root.mkdir(parents=True, exist_ok=True)

    resolved_plot_path: Optional[Path] = None
    resolved_report_path: Optional[Path] = None

    if generate_plot:
        filename = plot_filename or f"{trades_path.stem}_equity_curve.png"
        resolved_plot_path = output_root / filename
    if generate_report:
        filename = report_filename or f"{trades_path.stem}_report.md"
        resolved_report_path = output_root / filename

    if configure_logs:
        configure_logging(
            run_id=run_id or generate_run_id(),
            log_dir=Path(log_dir).expanduser() if log_dir else output_root / "logs",
        )

    logger.info(
        "starting trade analysis",
        extra={
            "trades_path": str(trades_path),
            "report_path": str(resolved_report_path) if resolved_report_path else None,
            "plot_path": str(resolved_plot_path) if resolved_plot_path else None,
        },
    )

    metrics = analyse_trades(
        df,
        trades_path,
        plot_path=resolved_plot_path,
        report_path=resolved_report_path,
        generate_plot=generate_plot,
        generate_report=generate_report,
    )

    formatted_summary = {label: value for label, value in format_metrics(metrics)}
    logger.info("analysis complete", extra={"metrics": formatted_summary})
    return TradeAnalysisResult(
        trades_path=trades_path,
        metrics=metrics,
        report_path=resolved_report_path if generate_report else None,
        plot_path=resolved_plot_path if generate_plot else None,
    )
